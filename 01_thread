2021/08/30 00:58
线程是一种提倡的编程方式的基础, 掌握线程的全部
创建和管理线程, 建立线程, 线程在程序中如何表示, 建立线程后对其的基本操作
线程的生命周期, 从线程建立到线程回收, 线程所有能够经历的调度状态

建立和使用线程
pthread_t tid;
int pthread_equal(pthread_t tid1, pthread_t tid2);
int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
pthread_t pthread_self(void);
int sched_yield(void);
int pthread_exit(void *value_ptr);
int pthread_detach(pthread_t tid);
int pthread_join(pthread_t tid, void **value_ptr);

线程是什么, 线程对计算机硬件的意义
线程在程序中的表现方式, 对程序的意义和能够对程序进行的操作

线程标识符ID
线程ID属于封装的pthread_t类型, 大部分时间线程ID保存在数据段/堆中
如果只需在函数中使用线程ID或函数直到线程终止才返回则可将线程ID声明为自动变量

Pthreads线程通过调用外界提供的函数开始
向pthread_create函数传递线程函数地址和线程函数调用的参数来创建线程

线程创建后返回pthread_t类型的线程ID并保存在*tid参数中交给程序引用该线程
线程可以通过调用pthread_self获取自身线程ID, 除以上2中别无他法获取线程ID

对线程进行任何操作都需要通过线程ID例如要知晓线程何时结束就需要保存线程ID
Pthreads提供了pthread_equal函数来比较两个线程ID是否相同(返回布尔值0:false/非0:true)
线程ID仅异同区分无先后大小之分, 初始线程(main线程)是特殊的

C程序执行时运行main函数, 该特殊执行流称为初始线程或主线程, 可以做任何线程能做的事情
main线程也可以调用pthread_self, pthread_exit等
若初始线程将其ID保存在其他线程能够访问的地方则其他线程可以等待初始线程终止或分离(detach)

初始线程的特殊性在于Pthreads在main函数返回(return)阶段保留了传统UNIX进程行为(exit)
即进程结束时不会等待其他线程结束, 而在其他线程函数中return相当于pthread_exit
线程一旦脱离进程范围就毫无意义, 因而进程结束时所有线程状态和返回值均自动销毁
分离一个正在运行的线程不会对线程任何影响只是通知操作系统该线程结束时其资源可回收

尽管线程蒸发方便有用但大部分时间进程要比创建的线程长命
为确保终止线程的资源对进程可用应在每个线程结束时分离它们
未被分离的线程终止时会保留其虚拟内存包括堆栈和其他系统资源
分离线程意味着通知操作系统不再需要此线程, 允许系统回收资源

创建一个从不需要控制的线程, 使用属性来建立以使其总是可分离的
若不想等待某个创建的线程且不再需要控制它可随时调用pthread_detach使其分离

线程可以分离自己, 任何获得其ID的其他线程可以随时使其分离
若需要获得线程的返回值或需要获知其何时结束应调用pthread_join函数
pthread_join函数将阻塞其调用者直到指定线程终止并获取其返回值
调用pthread_join函数自动分离指定的线程

进程内的线程能够同时使用不同的堆栈执行不同的指令
尽管线程彼此独立执行但总是共享一个地址空间和文件描述符
共享空间使得线程间高效通信, 这也是线程编程模型的一大优势

程序可能建立执行不相关的任务线程, 但大多时是一组线程共同工作以实现某个目标
如一组线程形成流水线工作方式, 每个线程在共享数据流上执行特定子任务并将结果传给下一线程
一组线程可以形成一个工作群体以完成同一任务的不同部分或某控制线程负责在一组工作线程间分配任务
也可以将上述模型以各种方式组合如某工作线程执行流水线中某个复杂步骤如矩阵列转换

lifecycle.c
--------------------------
#include "errors.h"
#include <pthread.h>

void *thread_routine(void *arg)
{
    return arg;
}

int main(int argc, char *argv[])
{
    pthread_t tid;
    void *result;
    int status;

    if ((status = pthread_create(&tid, NULL, thread_routine, NULL)) < 0)
        ERR_ABORT(status, "Create thread");

    if ((status = pthread_join(tid, &result)) < 0)
        ERR_ABORT(status, "Join thread");

    return result != NULL;
}
--------------------------
调用pthread_join等待线程结束否则无法知晓main在exit前其他线程已终止
可在main函数中调用pthread_exit这样进程就必须等到所有线程结束

让所有线程返回某个值是个好习惯否则底层会被编译成返回了某个寄存器rax什么的值
join一个线程时不关心返回值或者被join的线程根本不返回任何值则可向pthread_join函数的
&retval参数传递NULL此时被join的线程返回值将被忽略

当pthread_join调用返回时, 被join的线程便已被分离(detach)再也不能再次join
少数情况下多个线程需要知道某个特定线程何时结束
则这些线程应等待某个条件变量而不是调用pthread_join函数
被等待的线程应将其返回值(或其他任何信息)保存在公共位置
并将条件变量广播给所有在其上等待的线程以唤醒它们
2021/08/30 22:02

线程的生命周期
任意时刻线程处于四个基本状态之一, 但在实现中会有其他附加状态或者说每个状态的子状态
终止态可以分为退出和取消, 阻塞态可以分为条件变量阻塞, 互斥量阻塞, 读阻塞

线程状态
就绪(ready)
    线程能够运行, 但在等待可用的处理器
    可能刚刚启动, 或刚刚从阻塞中恢复, 或被其他线程抢占
运行(running)
    线程正在运行, 在多处理器系统中可能有多个线程处于运行状态
阻塞(blocked)
    线程由于等待处理器外的其他条件无法运行
    如条件变量的改变, 加锁互斥量或I/O操作结束
终止(terminated)
    线程从起始函数中返回, 或调用pthread_exit, 或被取消
    终止自己并完成所有资源清理工作
    不是被分离(detach)或连接(join), 一旦线程被分离或连接便可被回收

更细微的区别对于调试和分析线程程序很重要, 但对于理解线程不会有区别
线程开始处于就绪状态, 线程运行时调用特定的起始函数
线程可能被其他线程抢占或因等待外来事件而阻塞自己
最终线程完成工作, 或者从起始函数返回, 或者调用pthread_exit函数即进入终止状态
如果线程已被分离, 则立刻被回收重用(比销毁线程回收资源要好因为不用重新创建线程)
否则线程停留在终止态直到被分离或者被连接

线程状态间的转换关系及激发状态转换的事件:

      ------> 就绪态 <---(等待条件被满足) 阻塞态
      |       |   ^                         ^
   已创建     |   |(被抢占)       (等待资源)|
              |   ------       --------------
              ---------> 运行态
              (被调度)    |(完成或者被取消)
                          V
                         终止

创建线程
进程的初始线程随着进程的创建而创建
在完全支持线程编程的系统中可能没有代码能够脱离线程而运行
线程很可能是系统中包含执行代码所需硬件状态(寄存器, 程序计数器, 堆栈指针等)的惟一软件环境

main线程以外的其他线程通过显示的函数调用建立
Pthreads系统中建立线程的主要方式是调用pthread_create
如果进程的信号通知机制设为SIGEV_THREAD则当进程收到一个POSIX信号时也会创建线程
不同的操作系统也可能包含其他创建线程的方式

新线程创建后便处于就绪状态
受调度机制的限制, 新线程可能在就绪态停留一段时间后才被执行, 线程调度
例程lifestyle.c运行thread_routine函数的线程在main函数调用pthread_create时处于就绪状态
关于线程创建最重要的是, 在当前线程从函数pthread_create中返回及新线程被调度执行之间不存在同步关系
即新线程可能在当前线程从pthread_create返回之前就运行了
甚至在当前线程从pthread_create返回之前, 新线程便已运行完毕
线程创建时需要注意的信息

线程启动
一旦线程被创建便开始执行机器指令
初始指令序列将导致在pthread_create调用中指定的线程启动函数的执行
线程启动函数的运行参数也是在创建线程时指定的, 如lifestyle.c中传给thread_routinue函数的NUL参数
在初始线程中, 线程的启动函数即main函数是从程序外部被调用的
例如很多UNIX系统将程序链接到一个负责进程初始化的crt0.o文件上, 然后调用main函数

初始线程(main线程)与普通线程之间存在不同
如main函数的调用参数(argc和argv)与普通线程的启动参数(void *)不同
普通线程从启动函数中返回, 则线程终止而其他线程依然可以运行
初始线程从main函数中返回时, 进程终止(进程内所有线程也终止)
若希望初始线程终止时进程中其他线程继续执行则需要在初始线程中调用pthread_exit而非从main中return或exit

另一个重要的区别是, 大多数系统中初始线程运行在默认进程堆栈上, 该堆栈可以增长到足够的尺寸
而在某些实现中, 普通线程的堆栈空间是受限的, 若线程堆栈溢出则程序因段错误而失败

运行和阻塞
线程不可能一直保持清醒, 大多数线程会不时休眠等待某个资源可用(即被阻塞)
或因操作系统将处理器分配给其他线程(即被抢占)
线程大多数时候处于其生命周期中的三个状态: 就绪, 运行和阻塞

当线程刚被创建时或被解除阻塞再次可运行时便处于就绪状态, 等待可用的处理器
同样当一个运行线程被抢占时被时间片机制抢占(因以运行足够久)线程立即进入就绪状态
当处理器选中一个就绪线程执行时, 线程即进入运行态通常意味着某个其他线程被阻塞或被时间片机制抢占
则处理器会保存被阻塞(或抢占)线程的环境并恢复下一个就绪线程的环境
不过在多处理系统中一个未用的处理器可以执行一个就绪线程而不必由于其他线程被阻塞

线程在以下情况时被阻塞:
    试图加锁一个已被锁住的互斥量
    等待某个条件变量
    调用Singwait等待尚未发生的信号
    执行无法立即完成的I/O操作

线程还会由于如内存页错误之类的系统操作而被阻塞
线程等到某个事件发生后重新进入就绪状态, 若处理器可用则立即运行
lifestyle.c中主线程调用pthread_join等待创建的线程运行结束
若新线程此时尚未运行则将在主线程被阻塞后从就绪态进入运行态
当新线程运行完毕返回时主线程才会被解除阻塞返回就绪态
当处理器可用时主线程或者立即执行或者等到创建的线程终止后重新运行直到结束

终止
线程通常从启动函数中return来终止自己, 例如lifestyle.c中线程返回NULL后终止
调用pthread_exit退出线程或调用pthread_cancel取消线程时线程在调用完每个清理过程也进入终止状态
这些清理过程是由线程通过调用pthread_cleanup_push注册的且尚未通过调用pthread_cleanup_pop删除

线程还会有私有的"线程特定数据"
若线程有非空的私有数据则与这些数据相关的destructor函数将被调用

若线程已被分离则立即进入回收, 否则线程处于终止态, 这样就还可以被其他线程调用pthread_join连接
像UNIX中的进程已结束但还未被wait调用回收一样, 这类线程称为僵尸线程因为其生命已终结但资源仍存在
僵尸线程可能会保留其运行时大部分甚至所有资源因而不该让线程长时间处于这种状态
当创建不需要连接的线程时应使用detachstate属性建立线程使其自动分离

终止后的线程至少保留了线程ID(pthread_t类型的值)和void *类型的返回值
该返回值从线程启动函数中返回或在pthread_exit调用时设定
通过函数返回或pthread_exit调用正常终止的线程与通过取消调用终止的线程间的唯一外部区别:
    被取消的线程其返回值总是PTHREAD_CANCELLED
    这也是不把取消视为一种独立线程状态的原因

若有其他线程在等待连接进入终止态的线程
则该其他线程将被唤醒, 其将从pthread_join调用中返回相应的值
且终止线程被pthread_join函数分离或在pthread_join函数返回前被回收
因而返回值一定别是与终止线程栈相关的地址, 否则该地址上的值可能在调用线程能够访问之前便被覆盖

当需要获取返回值时, 建立分离的线程并定制自己的返回机制常与使用pthread_join一样简单
如传给一个工作线程某种形式的数据结构且该结构能够被其他线程访问
可以让工作线程简单地将结果保存在该数据结构中然后广播给某个条件变量
之后线程的环境数据(包括线程ID)便可被立即回收, 返回值始终存放在可以访问的地方

若pthread_join恰恰实现了想要的功能则一定要使用, 但切记其是最简单最受限的传递返回值模型
若pthread_join不能直接实现想要的功能则设计自己的返回机制而非扭曲设计来满足pthread_join的限制

回收
若使用detachstate属性(设为PTHREAD_CREATE_DETACH)建立线程
或调用pthread_detach分离线程, 则线程结束时将被立刻回收
若终止线程未被回收则其将一直处于终止态直至被分离(调用pthread_detach)
或者被连接(调用pthread_join), 线程一旦分离便不能再访问
lifestyle.c中运行thread_routinue的线程在主线程从pthread_join调用返回时将被回收

回收将释放所有在线程终止时未释放的系统和进程资源
包括保存线程返回值的内存空间, 栈和保存寄存器状态的内存空间等
一些资源可能在线程终止时被释放但在线程终止后上述资源便不该被访问

一旦线程被回收, 线程ID便无效了不能再连接/取消或执行其他操作, 终止线程的ID可能被分给新的线程
使用该ID调用pthread_cancel可能就会取消一个不同的线程而非返回ESRCH错误

终止线程将释放所有的系统资源, 但必须释放由该线程占有的程序资源
调用malloc或mmap分配的内存可以在任何时候由任何线程释放
互斥量, 条件变量和信号可以由任何线程销毁, 只要它们被解锁时没有线程等待但只有互斥量的主人能够再次解锁
若线程终止时还有加锁的互斥量则该互斥量就不能再次使用(因为不会被解锁)

2021/09/02 22:34
