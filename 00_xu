2021/08/18 23:53
关于线程的坚实基础, 强大的编程模型
利用多处理器的并行计算能力
自动使用I/O并发功能, 同时执行多个任务
多线程编程适用于网络应用, 缓解网络I/O的瓶颈问题
IEEE POSIX Pthreads 标准

基本的线程概念: 异步编程, 线程的生命周期和同步机制
高级话题: 属性对象, 线程私有数据, 实时调度

barrier, 读写锁, 工作队列管理器, 调试, 性能问题

关于线程, 如何使用线程, 线程是一种基本软件单元,
将进程看作包含了数据地址空间, 文件和若干数据处理线程的综合应用
高效利用系统资源, 界面友好, 在多处理器系统中执行更快, 调整编程思路

Pthreads, POSIX threads
并发, 同步, 调度, 语法和样式

多人间的协调并发工作, 线程间的同步和协调

线程
同步
使用线程的几种方式
线程高级编程

POSIX针对线程的调整
Real code
避免调试的提示
POSIX多线程快速参考
标准化过程展望

2021/08/20 01:34
Pthreads以一种优雅, 高效, 可移植的方式完成并发
线程的工作模式
异步: 任何两个彼此独立运行的操作是异步的
异步应用程序的编程模型, 其中线程模型的基本优点
线程是什么, 做什么, 何时使用

线程编程模型的思想
程序员: 工程师, 数学家, 艺术家的神奇组合
共享数据即同步对象, 在Pthreads中称为互斥量(mutex)
同步对象相关的通信机制
Pthreads提供条件变量(condition variable)通过信号和广播指示共享数据的状态变化

并行/异步编程
异步(asynchronous)表明彼此不相干事情相互独立发生, 除非有强加的依赖
并发(concurrency)事情同时发生, 让实际上可能串行发生的事情像同时发生
但处理器系统中线程/进程的行为特点
并发导致程序相互独立运行(不必等待另一个程序结束), 但不一定要同时运行
并发能够让程序发挥异步能力的优点
Pthreads提供了并发和异步的能力, 结合写出良好响应速度的程序
程序一面等待外设I/O一面利用多处理器系统的优势并行地进行其他计算

单处理器, 拥有超标量体系结构, 向量或其他IO协处理器的单一通用处理器
多处理器共享同一套指令集和同一块物理内存

并行(parallelism), 并发序列同时执行, 没有交错
并行只可能出现在多处理器系统中, 而并发可以出现在单处理器系统和多处理器系统中

线程安全和可重入
线程安全: 代码能够被多个线程调用而不会产生灾难性结果(安全地运行)
Pthreads提供的工具用于实现线程安全: 互斥量, 条件变量, 线程私有数据

不需要保存永久状态的函数可以通过整个函数调用的串行化(加锁解锁)来实现线程安全
更有效的是将线程安全函数分为多个小临界区, 允许多个线程进入函数但不能同时进入一个临界区
更好的方式是将代码改造为对临界数据的保护而不是对临界代码的保护

将互斥量和数据相关联, 保护对数据的访问而不是对代码的访问
如此访问代码依然是并行, 而访问数据则需要一个互斥量来安全地协调

可重入有时表示有效的线程安全,
采用比 将函数或库转换为一系列区域 更复杂的方式使代码成为线程安全的
通过引入互斥量和线程私有数据可以实现线程安全, 但需要改变接口使函数可重入
可重入的函数应避免依赖任何静态数据, 最好避免依赖线程间任何形式的同步

UNIX为了让readdir函数是线程安全的, 新增了一个互斥量, 调用时锁住返回时解锁
另一种做法readdir_r是避免函数内部任何锁操作, 而是让调用者在搜索目录时分配数据结构

并发控制功能
并发系统必须提供基本的核心功能, 包括创建并发执行的环境, 在程序中对其进行控制
任何并发系统都应具备的基本功能:
1.执行环境: 建立和清理执行环境, 独立维护状态(中断恢复)
2.调度: 决定某个时刻该执行何组, 在不同环境中切换
3.同步: 为并发执行的环境提供了协调访问共享资源的一种机制
这里同步是指"阻止同时发生", 即让线程协调完成工作机制

交通系统是一种并发系统, 汽车, 红绿灯, 转变信号和刹车灯
UNIX进程, 优先级调度, 等待和管道同步
PThreads线程, 策略和优先级调度, 条件变量和互斥量同步

系统调度功能:
1.线程执行直到自愿让出CPU(执行结束或IO阻塞)
2.时间片轮转使线程自愿让出CPU
多种调度策略, 根据线程功能选择各线程的调度方式
分类调度器, 描述线程间的依赖关系, 确保紧耦合的并行算法各成员同时被调度

同步可以通过多种方式实现, 最常见的是互斥量, 条件变量, 信号量和事件
还可以通过消息传递机制如UNIX管道, Socket, POSIX消息队列或其他异步进程间通信协议
任何通信协议都包含某种相同的同步机制, 若无则传递数据混乱便不是通信了

线程, 互斥量, 条件变量
线程是计算机中的可执行单元, 互斥量阻止线程间发生不可预估的冲突
一旦避免冲突, 条件变量便让线程等待直到可以安全地执行
互斥量和条件变量都是用来同步线程间操作的

通过Bash启动了一个程序在后台运行, 和Bash便是异步运行
使用管道(pipe)将命令输出重定位到另一个命令的输入时, 彼此便是通过管道来同步

先编写源代码, 再编译程序, 时间便是同步机制
$ ls | more # 软件同步机制: 管道, 通过设定数据依赖性来描述命令间的同步
ls和more两个命令并发执行, 在多处理器系统中甚至是真正的并行, 彼此独立但有同步
$ cc -o thread.o thread.c
编译过程中词法分析语法分析代码优化链接等可同时启动彼此通过管道或中间文件等同步

UNIX进程包含执行实体的全部信息, 因而可以异步执行
通用异步实体们必须包含被操作系统可以任意切换的足够状态
但UNIX进程还包含与执行环境不直接相关的附加状态数据, 如地址空间和文件描述符

线程是进程中的可执行实体
线程包括: PC指针寄存器, 栈指针寄存器, 通用寄存器, 浮点或地址寄存器
还可能包括处理器状态和协处理器寄存器等数据
线程不包括进程中的其他数据, 如程序文本段和数据段

线程视为一种减负的进程, 切换线程比切换进程快, 因为线程间共享代码段数据段栈段
同一进程中的线程共享相同的地址空间和其他进程数据
线程使程序不同部分间的高带宽通信更加容易, 同步更快
当打开了一个文件, 所有线程都可使用它, 当分配了一块动态内存,所有线程都可以引用
更方便地利用并发优点

异步模式, 因为并非所有事情都是顺序发生
两车道可以同时通两辆车, 编译构建大型软件项目时可以先做别的事不用时刻干预
商场收款机可以并行为客户服务而开俩队列, 虽然没快但减少了混乱
生产线并行, 办公室项目分多个部门, 都改善了性能

线程编程需要在不同情况下作出恰当取舍, 可以是多个线程执行相同的任务
也可以是多个线程分工完成同一任务的不同部分, 也可以是两种组合

互斥量, 条件变量, 竞争条件, 死锁, 优先级倒置
每个概念都能找到现实中的现象模型, 若没有便不要试图实现程序
线程管理和同步技术, 线程编程的细节

交互式闹钟程序
---------------------------------------
#include "errors.h"

int main(int argc, char *argv[])
{
    int seconds;
    char line[128];
    char message[64];

    for (;;) {
        printf("Alarm> ");
        if (fgets(line, sizeof(line), stdin) == NULL)
            exit(0);
        if (strlen(line) <= 1)
            continue;
        if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2)
            fprintf(stderr, "Band command\n");
        else {
            sleep(seconds);
            printf("(%d) %s\n", seconds, message);
        }
    }

    return 0;
}
---------------------------------------
交互式程序是把异步方式实现的工作用同步方式实现了

多进程版本
---------------------------------------
#include "errors.h"
#include <wait.h>
#include <sys/types.h>

int main(int argc, char *argv[])
{
    int status;

    char line[128];
    int seconds;
    pid_t pid;
    char message[64];

    for (;;) {
        printf("Alarm> ");
        if (fgets(line, sizeof(line), stdin) == NULL)
            exit(0);
        if (strlen(line) <= 1)
            continue;
        if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2)
            fprintf(stderr, "Bad command\n");
        else {
            pid = fork();
            if (pid < 0)
                ERRNO_ABORT("Fork");
            if (0 == pid) {
                sleep(seconds);
                printf("(%d) %s\n", seconds, message);
                exit(0);
            } else {
                do {
                    pid = waitpid(-1, NULL, WNOHANG); // 异步wait
                    if (pid < 0)
                        ERRNO_ABORT("Wait for child");
                } while (pid != 0);
            }
        }
    }

    return 0;
}
---------------------------------------

多线程版本
pthread_create
pthread_detch
pthread_exit
线程pthread_exit后Pthreads会保存线程资源以使其他线程了解其执行结果
---------------------------------------
#include "errors.h"
#include <pthread.h>

typedef struct alarm_tag {
    int seconds;
    char message[64];
} alarm_t;

void *alarm_thread(void *arg)
{
    int status;
    alarm_t *alarm = arg;

    // 分离自己, 告知Pthreads不必关心其终止时间和退出状态
    status = pthread_detach(pthread_self());
    if (status != 0)
        ERR_ABORT(status, "Detach thread");

    sleep(alarm->seconds);
    printf("(%d) %s\n", alarm->seconds, alarm->message);

    free(alarm);
    return NULL;
}

int main(int argc, char *argv[])
{
    int status;
    char line[128];
    alarm_t *alarm;
    pthread_t thread;

    for (;;) {
        printf("Alarm> ");
        if (fgets(line, sizeof(line), stdin) == NULL)
            exit(0);
        if (strlen(line) <= 1)
            continue;
        alarm = (alarm_t *)malloc(sizeof(alarm_t));
        if (NULL == alarm)
            ERRNO_ABORT("Allocate alarm");
        if (sscanf(line, "%d %64[^\n]", &alarm->seconds, alarm->message) < 2) {
            fprintf(stderr, "Bad command\n");
            free(alarm);
        } else {
            status = pthread_create(&thread, NULL, alarm_thread, alarm);
            if (status != 0)
                ERR_ABORT(status, "Create alarm thread");
        }
    }
}
---------------------------------------

多进程和多线程闹钟两个异步版本
多进程有各自独立的地址空间, 多线程共享同一地址空间
线程分离自己, pthread_exit后资源即被回收

实际应用中, 系统可能无法一下子创建上百个进程, 但却可以快速创建上百个线程
线程不需要保存多份堆栈和环境, 因而是个很有生命力的设计

在线程间传消息要快得多, 因为不需要共享内存, 不需要通过管道读写
不需要担心进程间传递的地址指针是否一致
线程间共享一切, 一个线程内有效的地址指针在所有线程内同样有效

线程的优势
多线程编程模型具有以下优点:
1.多处理器系统中开发程序的并行性(真正的并行需要硬件支持)
2.等待慢速外设IO时程序可以执行其他计算, 开发方式更自然有效
3.模块化编程模型, 能清晰表达程序中独立事件间的相互关系

并行
在多处理系统中, 线程模式可以让一个进程同时执行多个独立运算
一个运行在双CPU上的计算密集型多线程程序几乎可以获得传统单线程程序两倍的性能
几乎是因为: 创建额外的线程和执行线程间的同步会带来额外的开销, 成为可扩展性
可扩展性总是随CPU数量增加而下降, 因为存在更多耗时的锁操作和内存冲突

Amdahl法则预测可扩展性:
提升后的速度 = 1 / ((1 - p) + (p / n))
p代表可并行部分占整个执行时间的比率, n代表可以使用的CPU数目
显示了串行限制并行的简单关系, p=0即无可并行代码速度提升为0
p=1即全部代码可并行速度为原来的n倍, 需要的同步越多则并行带来的好处越少
即完全无关的活动比高度相关的活动更有可扩展性, 因为独立活动之间需要更少的同步

对于大矩阵上的操作即可通过矩阵分块来实现并行计算
例如让每个线程对矩阵的一组行或列执行操作相互独立
除了在结束时需要使用barrier同步线程(一种简单的同步机制)

Amdahl法则帮助理解可扩展性
但精确计算程序的p值需要考虑代码所有的串行段甚至操作系统内核和硬件因素
如多处理器系统的硬件必须提供一些同步访问内存的机制
每个处理器自己的高速缓存必须与其他处理器以及内存中的数据保持一致

并发
线程编程模式允许程序在等待IO之类的阻塞操作时继续其他计算
对于网络服务器和客户端是有用的, 也因此客户/服务器系统使用线程
UNIX系统支持非阻塞式IO, 但与异步IO不是一回事
非阻塞式IO允许程序推迟执行IO操作直到能够不被中断地完成
异步IO能在程序执行其他操作的同时继续进行
大部分UNIX系统不支持异步IO, 异步IO比线程更加复杂

IO完成时处理异步通知或轮询(poll)等待其完成
若执行异步IO操作进行polling循环, 就失去了异步IO操作的优势而完全等待
如果在程序其他地方轮询或处理异步通知然后执行IO和处理结果数据会使代码分析更加困难
使用同步IO可以执行IO操作后再继续工作
在多线程中使用同步IO能提供与异步IO几乎相同的好处
写基于线程的复杂异步代码比传统异步编程技术容易得多

可以写一个异步闹钟而不使用进程或线程
使用时钟信号作为闹铃, 将异步的读取时钟信号作为输入
使用时钟信号更复杂因为完全受限于一个信号处理程序中能完成的工作
异步IO不允许使用stdio函数库且由一系列信号处理组成的程序难以理解

异步IO比同步线程有一个优势: 异步IO操作的环境要求几乎总是比线程开销更为有效
若同时需要执行许多异步IO操作, 则使用异步IO模式可能更为有效
有些异步IO的底层实现只是将IO请求在线程缓冲池内分发而已

另一种编写异步应用的方法是将每个活动视为事件
事件由隐藏的后台进程排队串行分派被进程处理: 通常使用向分派器注册过的回调函数
事件分派器广泛用于图形界面系统, 大大减少了使用信号和异步IO的复杂度

事件机制大大减少了使用信号和异步IO的复杂度, 只要事件由分派器直接支持
用事件接口编写的程序只需要初始化事件分派器并循环处理事件
输入事件应转发到解析器导致一个新的程序请求, 程序则应转发到一个处理函数中

基于事件的实现比基于进程或线程的实现更简单, 但创建更复杂的程序时限制明显因为事件是串行处理的
事件不是并发的, 基于事件的系统一次只能做一件事, 程序收到一个事件然后处理再等下一事件
类似大型数据库的排序或低速网络连接读取数据这种长时间处理导致用户操作延迟响应

响应速度问题可以通过在事件分派器中处理额外操作来最小化
但要在合适的位置处理它而根本不影响操作性能可能很困难
也可以专门创建排序数据库线程而开启另一线程继续处理用户输入
或将排序命令传到串行执行数据库操作的服务器线程中排队等待处理而始终保持用户界面响应

线程模型
即使程序从不在多处理器系统上运行, 线程编程模型仍值得, 其迫使思考和安排程序中的同步需求
总是需要考虑程序的依赖性, 线程帮助将这种需求移到程序结构中

如C编程语言中的流程控制结构比汇编语言清晰
而C++编程语言的数据封装和多态机制比C语言更清晰

在串行程序中, 同步需求隐藏在操作顺序中而真正的同步需求只能由源代码中的注释记录
线程编程时串行假设应由显示的同步结构加以确保

串行编程模型中先调用A函数再调用B函数, 严格的串行模型容易使函数B依赖于函数A的部分结果
程序中A和B的依赖关系由源代码注释可能模糊不清后期也无法及时更新
线程编程模型将独立或低耦合的功能执行流(线程)显式分离
每个函数必须包括显式的同步以确保依赖关系, 同步机制是可执行代码包含依赖信息
同步结构的存在让人显式理解代码间时间依赖的关系, 尤其是对于包含大量独立代码的大型程序

汇编程序员可以通过理解高级语言写出更好的可维护代码
C程序员通过理解OOP可以写出更好的可维护代码
即使从不使用多线程也可以从理解独立函数线程编程中收益
独立于特定串行代码的模型或者叫作编程范式
清楚地分离功能独立的代码可以使串行程序更易理解和维护

2021/08/27 22：34
线程的代价
线程的强大优势即使在但处理器系统中也依然存在
在多处理系统中甚至能提供更多的好处
不使用线程是因为代价超过了好处因而不值得

线程代码中的负荷代价包括由于线程间同步导致的直接影响如时间代价
几乎没有全能的避免同步的算法, 线程代码中总是需要使用某种同步机制的
使用太多的同步很容易损失性能如两个以上线程同时访问两个独立的受保护的变量

线程编程的负荷还可能包括更多细微的影响
如一直向同一内存地址写数据的线程在支持读写排序的处理器上可能需要大量的时间用于同步
有些处理器在线程使用特殊指令如原子操作时花费事件同步

从程序中排除瓶颈代码, 如添加线程来执行多个并发IO操作可能会妨碍其他底层的瓶颈问题如
C库, 操作系统, 文件系统, 设备驱动程序, 内存和IO结构或设备控制器, 难以测量评估

一个很少被外部事件阻塞的计算密集型线程无法与同类其他线程有效地共享一个处理器
一个IO线程可能隔段时间会中断一次, 计算密集型线程再次运行
若创建的计算密集型线程比可用的处理器多则可能比单线程实现获得更好的代码结构但
程序性能此时也许不如单线程, 因为频繁的线程切换反而成为运行瓶颈
性能的损失是由于多线程额外增加了同步和调度开销而可用资源却不变

编程规则
线程编程模型基本思想简单但编写实际代码却不容易, 需要认真的思考和计划
需要理解同步协议和程序中的不变量, 不得不避免死锁, 竞争和优先级倒置
尽量使用库代码而不是自己编写, 操作系统提供的大部分库函数能安全地用于多线程程序中
POSIX标准保证由ISO C和POSIX提供的大部分函数必须在多线程应用中安全地使用

有些函数如数据库软件提供的可能不是线程安全的, 需要用到一些不安全的技巧
一个进程中的所有线程共享地址空间, 线程间没有保护界限
如果一个线程使用未初始化的指针写内存则可能破坏其他线程的栈或堆空间
若库函数支持回调函数则必须保证库函数和回调函数都是线程安全的

好的串行代码不一定是好的线程代码而不好的线程代码更难以定位和修正错误
考虑现实中的并行事例会有帮助但编程比实际生活需要更多细致的工作

难以调试
有关调试线程代码的知识, 有用的工具和调试技巧, 关于互斥量和内存可视性
学会解决死锁和竞争问题, 线程调试
提供线程功能的系统通常会将传统的串行调试工具扩展用以提供基本的线程调试支持
系统提供的调试器允许看到所有线程的调用结构树, 并设置只能在特定线程内激活的断点
系统可能提供某种形式的性能分析器以计算某个线程或者所有线程中函数的累计占用处理器的时间

调试异步代码, 不可避免地改变事件的时序
在调试串行代码时无问题但调试异步代码时确是致命的
遇到无法复现的错误在线程中十分普遍

在串行程序中跟踪内存错误已经十分困难, 在线程程序中更加复杂
也许是其他线程未通过互斥量便访问了内存
也许是使用了错误的互斥量
也许是其他线程建立了指针而未显示同步
也许是与传统串行程序类似的内存错误

系统提供的各种调试工具没有一个是标准或流行的
可能会检查源代码中明显的锁协议违规并给出有关共享变量和如何加锁共享变量的定义
可能会记录程序运行过程中线程间交互的过程以允许程序员分析甚至重现线程间的交互
可能会记录并度量同步竞争和负荷, 可能会检测到互斥量集合中复杂的死锁条件

其实旧式的人工阅读源代码的方式, 大脑便是最强大最通用的线程调试工具
需要花时间建立断点和测试大量的状态来缩小错误范围区域然后认真阅读找出错误

选择线程还是不用线程
线程无需给出所有编程问题最好的解决方案, 线程也并非总是容易使用, 也并非总是能达到最好的性能
有些问题本身就是非并发的, 添加线程只能降低程序的性能增加程序复杂度
最适合使用线程的是实现以下功能的应用:
1.计算密集型应用, 能在多处理器系统上运行, 将这些计算分解到多个线程中实现
2.IO密集型应用, 为提高性能将IO操作重叠, 多个线程同时等待不同的IO操作如
    分布式服务器应用必须响应多个客户的请求, 必须为通过慢速的网络连接主动提供IO做好准备
大部分程序有一些本质上的并发, 即使那种在处理命令的同时从输入设备中读取下一个命令的简单并发
多线程程序通常比串行程序更快, 响应性能更好, 比实现同样功能的非线程异步程序更易于开发和维护
线程编程不必用在所有的程序中但软件开发人员都应该理解线程技术

POSIX线程概念
线程API遵循POSIX.1c标准, 而POSIX.1b规范实时机制标准, POSIX.14多处理器系统主题
若是开发线程机制的底层实现则可能需要读POSIX标准

线程的3个基本要素: 执行环境, 调度和同步
在评估任一线程系统或比较任意两个线程系统时, 都可以从比较此三方面的支持开始
使用Pthreads通过pthread_create创建执行环境(线程)
创建一个线程同样也调度了该线程的执行, 这将通过调用指定的线程启动函数开始
Pthreads允许在创建线程时指定调度参数, 或者在线程运行时设定
当线程调用pthread_exit时退出或从线程启动函数中返回时退出, 也有其他可能性

基本的Pthreads同步模型使用互斥量来保护共享数据, 使用条件变量来通信
还可以使用其他同步机制如信号量, 管道和消息队列
互斥量允许线程在访问共享数据时将其锁定以避免其他线程的干扰
条件变量允许线程等待共享数据到达某个期望的状态(队列非空或资源可用)

类型和接口
Pthreads数据类型, 如何创建和使用

POSIX线程数据类型
pthread_t 线程标识符
pthread_mutex_t 互斥量
pthread_code_t 条件变量
pthread_key_t 线程私有权握访问键
pthread_attr_t 线程属性对象
pthread_mutexattr_t 互斥量属性对象
pthread_condattr_t 条件变量属性对象
pthread_once_t 一次性初始化控制变量
所有数据类型都是不透明的(黑盒)
可移植的代码不能对这些数据类型的实现作任何假设, 只能按照标准中描述的方式使用

线程标识符ID可能是整型, 或者是浮点类型, 或者是结构体类型
任何以不能兼容上述所有定义的方式使用线程ID的代码都有误

错误检查
Pthreads引入了一种全新的报错方式, 而没有使用errno变量
Pthreads修订版是POSIX中第一个与传统UNIX和C语言报错机制相分离的部分
传统上函数返回时返回有效值或者指示调用成功的0值而在错误发生时返回特定的-1值
并对全局变量errno赋值以表示错误类型

传统的报错机制存在问题如函数返回的有效值包含-1
引入多线程时更复杂, UNIX系统中errno是一个extern int变量只支持进程中的单一执行流
Pthreads中新函数有时不会设置errno变量, 而其他大部分POSIX函数会这样做

Pthreads中新函数通过返回值表示错误状态而非使用errno变量
成功时Pthreads函数返回0并包含一个额外的输出参数来指向存有有用结果的地址
当错误发生时函数返回包含errno.h头文件中的错误代码

Pthreads同样提供了一个线程内的errno变量以支持其他使用errno的代码
读写线程内的errno变量要比读写进程虚拟内存空间的变量或返回值开销更大

等待线程结束的pthread_join函数遇到无效线程ID会返回错误代码ESRCH
大多数实现中未初始化的pthread_t线程变量就是无效的线程ID
thread_error.c中存在一种不太可能发生的情况:
    未初始化的pthread_t变量拥有一个有效的值
    则该值一定是初始线程的ID(因为进程中没有其他ID)
    此时若Pthreads实现了自死锁检测功能则pthread_join函数返回错误码EDEADLK
    否则线程将挂起等待自己退出(即自死锁)
thread_error: No such process
----------------
#include <errno.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>

int main(void)
{
    int status;
    pthread_t tid;
    if ((status = pthread_join(tid, NULL)) != 0)
        fprintf(stderr, "error %d: %s\n", status, strerror(status));
    return status;
}
----------------

Pthreads没有像perror函数一样自动读取errno值打印错误信息的函数
毕竟Pthreads的错误码是返回值只有调用者自己知道

Pthreads报错机制中的一个例外是pthread_getspecific函数
仅返回线程私有数据: 共享的Key值
对很多应用来说管理线程私有数据的能力至关重要
函数必须尽快执行完因而pthread_getspecific函数根本不报错
若pthread_key_t值无效或线程未对其赋值则pthread_getspecific函数返回NULL

2021/08/28 00:56
